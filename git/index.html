<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Git - Yvan Blog</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Git";
    var mkdocs_page_input_path = "git.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Yvan Blog</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <p class="caption"><span class="caption-text">个人信息</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">前言</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../resume/">个人简历</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">技术分享</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../technology/">Technology</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">个人分享</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../book/">图书分享</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../calendar/">日历</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">个人学习笔记</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="#">Python</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../python/">Python</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../python_wsgi/">Python WSGI</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Sql and NoSql</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../mongodb/">MongoDB</a>
                </li>
                <li class="toctree-l2"><a class="" href="../mysql.dm">Mysql</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="#">Git</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Git</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#git_1">git基本使用</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_1">初始化</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_2">添加</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_3">展示版本</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_4">版本回退</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_5">版本前进</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_6">查看操作记录</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_7">查看当前工作区修改</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_8">提交入暂存区</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_9">撤销工作区的更改</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_10">撤销暂存区的更改</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_11">文件对比</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_13">删除文件</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_14">分支</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#gitpro">GitPro</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#git_2">git配置</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#git_3">git基础</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">C#</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../cshirp/">C#</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">JavaScrip</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../javascrip/">JavaScrip</a>
                </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="#">Java</a>
    <ul>
                <li class="toctree-l2"><a class="" href="Java:'java.md'">None</a>
                </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">个人阅读笔记</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../marxism_leninism/">марксизм-ленинизм</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../temp/">Temp</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../about/">关于</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Yvan Blog</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Git &raquo;</li>
        
      
        
          <li>个人学习笔记 &raquo;</li>
        
      
    
    <li>Git</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="git">git</h1>
<p>该版本仅为快速记忆查询命令，之后会将阅读《git pro》的读书笔记上传。<br />
但时间不确定，格式需要重新整理，数据也要重做。</p>
<h2 id="git_1">git基本使用</h2>
<h3 id="_1">初始化</h3>
<pre><code>    git init
</code></pre>

<h3 id="_2">添加</h3>
<pre><code>    git add WebServer/
    git commit -m 'apach_0.01'
</code></pre>

<h3 id="_3">展示版本</h3>
<pre><code>    git log
    commit fdc485a3ccd6081855e7fc12d772e051e59be165 (HEAD -&gt; master)
    Author: root &lt;root@DESKTOP-P2IBM15.localdomain&gt;
    Date:   Fri Feb 1 16:00:30 2019 +0800

        apach_0.02

    commit e514ea2d45025baa48f508a3c3dbca95b71d03db
    Author: root &lt;root@DESKTOP-P2IBM15.localdomain&gt;
    Date:   Fri Feb 1 15:49:55 2019 +0800

        apach_0.01
</code></pre>

<h3 id="_4">版本回退</h3>
<pre><code>    #退回上一个版本
        git reset --hard HEAD^
        Git reset --hard HEAD~1
        HEAD is now at e514ea2 apach_0.01

        -&gt;
            commit e514ea2d45025baa48f508a3c3dbca95b71d03db (HEAD -&gt; master)
            Author: root &lt;root@DESKTOP-P2IBM15.localdomain&gt;
            Date:   Fri Feb 1 15:49:55 2019 +0800

                apach_0.01
</code></pre>

<h3 id="_5">版本前进</h3>
<pre><code>    #前进到某个版本
        git reset --hard fdc485a3ccd6081（commit）
        HEAD is now at fdc485a apach_0.02
</code></pre>

<h3 id="_6">查看操作记录</h3>
<pre><code>    git reflog
    fdc485a (HEAD -&gt; master) HEAD@{0}: reset: moving to fdc485a3ccd6081
    e514ea2 HEAD@{1}: reset: moving to HEAD^
    fdc485a (HEAD -&gt; master) HEAD@{2}: commit: apach_0.02 （版本commit）
    e514ea2 HEAD@{3}: commit (initial): apach_0.01
</code></pre>

<h3 id="_7">查看当前工作区修改</h3>
<pre><code>        git status
    On branch master
    Changes not staged for commit:
        (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
        (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

            modified:   WebServer/ProcessServer.py

    no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>

<h3 id="_8">提交入暂存区</h3>
<pre><code>    root@DESKTOP-P2IBM15:/mnt/c/Users/Night/Documents/python# git add WebServer/
    root@DESKTOP-P2IBM15:/mnt/c/Users/Night/Documents/python# git status
    On branch master
    Changes to be committed:
        (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

            modified:   WebServer/ProcessServer.py
</code></pre>

<h3 id="_9">撤销工作区的更改</h3>
<pre><code>    #查询
        git status
        On branch master
        Changes not staged for commit:
            (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
            (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

                modified:   WebServer/ProcessServer.py

        no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
    #撤销
        git checkout --WebServer/ProcessServer.py
</code></pre>

<h3 id="_10">撤销暂存区的更改</h3>
<pre><code>    git add WebServer/
    #撤销暂存区
    git reset HEAD WebServer/
    Unstaged changes after reset:
    M       WebServer/ProcessServer.py

    #撤销工作区
    git checkout -- WebServer/
</code></pre>

<h3 id="_11">文件对比</h3>
<h4 id="head">与 HEAD 版本中的内容对比</h4>
<pre><code>`-#` 记载配置项
`+#` 加载配置项
</code></pre>
<pre><code>    git diff HEAD -- ProcessServer.py
    diff --git a/WebServer/ProcessServer.py b/WebServer/ProcessServer.py
    index c0217d4..ae28dfe 100644
    --- a/WebServer/ProcessServer.py
    +++ b/WebServer/ProcessServer.py
    @@ -14,8 +14,6 @@ class WSCIServer(object):
                self.application = applic
                self.static_path = static_path
                self.tcpServerSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    -        # 设置当服务器先close 即服务器端4次挥手之后资源能够立即释放
    -        # 这样就保证了，下次运行程序时 可以立即绑定7890端口
                self.tcpServerSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                self.tcpServerSocket.bind((&quot;&quot;, port))
                self.tcpServerSocket.listen(128)
    @@ -116,11 +114,11 @@ class WSCIServer(object):
                    respServerSocket, client_addr = self.tcpServerSocket.accept()
                    proc = multiprocessing.Process(target=self.serverClient, args=(respServerSocket, client_addr, ))
                    proc.start()
    -            respServerSocket.close() #关闭主线程中的respServerSocket
    +            respServerSocket.close()

                self.tcpServerSocket.close()

        class InitConfig(object):
            def __init__(self):
                self.dynamic_path = None
    @@ -158,4 +156,3 @@ def main():
        if __name__ == &quot;__main__&quot;:
            main()

    -# python3 ProcessServer.py 7890 MiniFrame:application
</code></pre>

<h4 id="_12">对比两个版本间文件的不同</h4>
<pre><code>    git diff HEAD^ HEAD -- ProcessServer.py
    diff --git a/WebServer/ProcessServer.py b/WebServer/ProcessServer.py
    index 95ba9b8..c0217d4 100644
    --- a/WebServer/ProcessServer.py
    +++ b/WebServer/ProcessServer.py
    @@ -82,11 +82,9 @@ class WSCIServer(object):

            # 动态文件处理
            def wopFile(self, fileName, respServerSocket):
    -        # responseHeader = responseHeader.encode(&quot;utf-8&quot;)
                environ = dict()
                environ['PATH_INFO'] = fileName
                responseBody = self.application(environ, self.set_response) # (字典， 函数)
    -        # &quot;HTTP/1.1 %s\r\n&quot; %self.status
                responseHeader = self.responseHeader.encode(&quot;utf-8&quot;)
                responseBody = responseBody.encode(&quot;utf-8&quot;)
                response = responseHeader + responseBody
    @@ -105,7 +103,7 @@ class WSCIServer(object):
                            fileName = &quot;/index.wop&quot;
                        print(fileName)
                        if not fileName.endswith(&quot;.wop&quot;):
    -                    &quot;&quot;&quot;静态文件&quot;&quot;&quot;
    +                    # 静态                  ^M
                            self.staticFile(fileName, respServerSocket)
                        else:
                            # .wop 动态
</code></pre>

<h3 id="_13">删除文件</h3>
<pre><code>    rm -rf run.sh
    git status
    On branch master
    Changes not staged for commit:
        (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
        (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

            modified:   ProcessServer.py
            deleted:    run.sh

    no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)

    #将删除的文件信息载入暂存区
        git rm run.sh
        rm 'WebServer/run.sh'

    #撤销残存区删除
        git reset HEAD run.sh
        Unstaged changes after reset:
        M       WebServer/ProcessServer.py
        D       WebServer/run.sh

    #撤销删除
        git checkout -- run.sh

    #单行log
        git log --pretty=oneline
        eda9b251b3e16493dd76fab77ac7b04d0c35c5aa (HEAD -&gt; master) apach_0.03
        fdc485a3ccd6081855e7fc12d772e051e59be165 apach_0.02
        e514ea2d45025baa48f508a3c3dbca95b71d03db apach_0.01
</code></pre>

<h3 id="_14">分支</h3>
<pre><code>    #查看当前分支
        git branch
        * master

    #创建并切换到一个新的分支中
        git checkout -b dev
        M       WebServer/ProcessServer.py
        Switched to a new branch 'dev'

        git branch
        * dev
            master

    #切换分支
        git checkout master
        Switched to branch 'master'
        git branch
            dev
        * master

    #快速合并
        git merge dev
        Updating eda9b25..1780993
        Fast-forward
            WebServer/ProcessServer.py | 11 ++---------
            1 file changed, 2 insertions(+), 9 deletions(-)

    #删除分支
        git branch -d dev
        Deleted branch dev (was 1780993).
</code></pre>

<h2 id="gitpro">GitPro</h2>
<p>注<br />
- <code>-&gt;</code> 在单行中表示上一个命令的结果或输出.</p>
<h3 id="git_2">git配置</h3>
<p>Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的配置变量。这些变量存储在三个不同的位置:<br />
1. <code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置.如果在执行 git config 时带上--system 选项,那么它就会读写该文件中的配置变量。 <br />
(由于它是系统配置文件,因此你需要管理员或超级用户权限来修改它。)<br />
2. <code>~/.gitconfig</code>或<code>~/.config/git/config</code> 文件:只针对当前用户。 你可以传递 --global 选项让 Git读写此文件,这会对你系统上所有的仓库生效。<br />
3. 当前使用仓库的Git目录中的<code>config</code>文件(即<code>.git/config</code>):针对该仓库.你可以传递 --local 选项让 Git 强制读写此文件,虽然默认情况下用的就是它. (当然,你需要进入某个 Git 仓库中才能让该选项生效。)每一个级别会覆盖上一级别的配置,所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。<br />
4. 你可以通过以下命令查看所有的配置以及它们所在的文件: <code>$ git config --list --show-origin</code>  </p>
<pre><code>$ git config --global user.name 'lvyvan'
$ git config --global user.email 'yvanlv@outlook.com'
# 文本编辑器
$ git config --global core.editor emacs
# 检查配置信息  
$ git config --list
</code></pre>

<h3 id="git_3">git基础</h3>
<h4 id="git_4">将尚未进行版本控制的本地目录转换为<code>Git</code>目录;</h4>
<p><code>git init</code>该命令将创建一个名为<code>.git</code>的子目录,这个子目录含有你初始化的Git仓库中所有的必须文件,这些文件是Git仓库的骨干.   </p>
<pre><code>x:~/Git/my_project$ git init
已初始化空的 Git 仓库于 /home/yvan/Git/my_project/.git/
ls -a
    .  ..  .git
</code></pre>

<p>此时,只是完成了一个初始化的操作,项目文件还没有被跟踪.使用<code>git add</code>命令来指定所需的文件来进行追踪,然后执行<code>git commit</code>  </p>
<pre><code>    $ git add *  
    $ git commit -m 'initial project version'
</code></pre>

<h4 id="git_5">从其他服务器克隆一个已经存在的<code>Git</code>仓库;</h4>
<ul>
<li>获得一份已经存在的Git仓库拷贝,使用<code>git clone</code>命令;</li>
<li>Git区别与其它版本控制系统的一个重要特性,Git克隆的是该Git仓库服务器上的几乎所有的数据,而不是仅仅复制完成你工作所需要文件.当执行<code>git clone</code>命令的时候,默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来.</li>
<li>事实上,事实上,如果你的服务器的磁盘坏掉了,你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库(虽然可能会丢失某些服务器端的钩子(hook)设置,但是所有版本的数据仍在)</li>
<li>克隆仓库的命令是 <code>git clone &lt;url&gt; &lt;newname&gt;</code></li>
<li><code>Git</code>支持多种数据传输协议.<code>https://协议</code>,<code>git://协议</code>,<code>SSH传输协议</code>,比如<code>user@server:path/to/repo.git</code></li>
</ul>
<h4 id="_15">文件状态</h4>
<ul>
<li>工作目录下的每一个文件都两种状态:已跟踪或未跟踪.已跟踪的文件是指那些被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能是未修改,已修改或放入暂存区.即已跟踪的文件就是Git已经知道的文件.</li>
<li>工作目录中除已跟踪的文件外的其他所有文件都属于未跟踪文件,他们既不存在于上次快照的记录中,也没有被放入暂存区.初次克隆某个仓库的时候,工作目录中的所有文件都属于已追踪文件,并处于未修改状态,因为Git刚刚检出它们,而且尚未编辑过它们.</li>
<li>编辑过某些文件之后,由于自上次提交后你对它们做了修改,Git将它们标记为已修改文件.在工作时,可以选择性的将这些修改过的文件放入暂存区,然后提交所有已暂存的修改,如此反复.</li>
<li>用<code>git status</code>命令查看哪些文件处于什么状态.</li>
</ul>
<pre><code>位于分支 master
尚未暂存以备提交的变更：
  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
        修改：     docs/git.md

修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）
</code></pre>

<h4 id="_16">跟踪新文件</h4>
<ul>
<li>使用命令<code>git add</code>开始跟踪一个文件</li>
<li>此时运行<code>git status</code>命令,会看到文件已被跟踪,并处于暂存状态.</li>
<li>只要在<code>Changes to be committed</code>这行下面的,就说明是已暂存状态.如果此时提交,那么该文件在运行<code>git add</code>的的版本将被留存在后续的历史记录中.</li>
<li><code>git add</code>命令使用文件或目录的路径作为参数,如果参数是目录的路径,该命令将递归的跟踪该目录下的所有文件.</li>
</ul>
<h4 id="_17">暂存已经修改的文件</h4>
<ul>
<li>当修改某个已被跟踪的文件后,运行<code>git status</code>命令;</li>
<li>文件出现在<code>Change not staged for commit</code>下面,说明以追踪文件的内容发生了变化,但还没有放到暂存区.要暂存这次更新,需要运行<code>git add</code>命令.这是个多功能命令:可以用它开始跟踪新文件,或者把已跟踪的文件放到暂存区,还能用于合并时把有冲突的文件标记为以解决状态等.将这个命令理解为"精确的将内容添加的下一次提交中",而不是"将一个文件添加到项目中"要更加合适.</li>
<li>将文件及暂存,下次提交时就会一并记录到仓库.此时,再次修改文件,并再次运行<code>git status</code></li>
<li>此时,文件同时出现在暂存区和非暂存区.Git只暂存运行<code>git add</code>命令时的版本.如果此时提交,则文件版本为最后一次运行<code>git add</code>命令时的版本.</li>
<li>所以,运行<code>git add</code>之后又作了修订的文件,需要重新运行<code>git add</code>命令将最新版本暂存起来.</li>
</ul>
<pre><code>$ git add docs/git.md 
$ git status
位于分支 master
要提交的变更：
  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）
        修改：     docs/git.md

# secont
$ git status
位于分支 master
要提交的变更：
  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）
        修改：     docs/git.md

尚未暂存以备提交的变更：
  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
        修改：     docs/git.md
</code></pre>

<h4 id="_18">状态简览</h4>
<ul>
<li><code>git status</code>命令的输出十分详细,但其形式有些繁琐</li>
<li>使用<code>git status -s</code>命令或<code>git status --short</code>命令,将得到更为紧凑的输出;</li>
<li>新添加的未跟踪文件 <code>??</code> 标记;</li>
<li>新添加到暂存区中的文件前面有<code>A</code>标记;</li>
<li>修改过的文件前面有<code>M</code>标记.</li>
<li>输出中有两栏,左边指明了暂存区的状态,右边指明了工作区的状态.</li>
</ul>
<pre><code>$ git status -s
MM docs/git.md
</code></pre>

<h4 id="_19">忽略文件</h4>
<ul>
<li>有些文件无需纳入Git的管理,也不希望它们出现在未跟踪文件列表。通常都是些自动生成的文件,比如日志文件,或者编译过程中创建的临时文件等。在这种情况下,可以创建一个名为<code>.gitignore</code>的文件,列出要忽略的文件的模式。</li>
<li>第一行告诉Git忽略所有以<code>.o</code>或<code>.a</code>结尾的文件.一般这类对象文件和存档文件都是编译过程中出现的.第二行告诉 Git 忽略所有名字以波浪符<code>(~)</code>结尾的文件,许多文本编辑软件(比如Emacs)都用这样的文件名保存副本.此外,你可能还需要忽略<code>log</code>,<code>tmp</code>或者<code>pid</code>目录,以及自动生成的文档等等.</li>
<li>文件 .gitignore 的格式规范如下:<blockquote>
<ol>
<li>所有空行或者以 # 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配,它会递归地应用在整个工作区中.</li>
<li>匹配模式可以以(/)开头防止递归。</li>
<li>匹配模式可以以(/)结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录,可以在模式前加上叹号(!)取反.  </li>
</ol>
</blockquote>
</li>
<li>所谓的 glob 模式是指shell所使用的简化了的正则表达式.星号<code>(*)</code>匹配零个或多个任意字符;<code>[abc]</code>匹配任何一个列在方括号中的字符(这个例子要么匹配一个 a,要么匹配一个 b,要么匹配一个 c);问号<code>(?)</code>只匹配一个任意字符;如果在方括号中使用短划线分隔两个字符, 表示所有在这两个字符范围内的都可以匹配(比如<code>[0-9]</code>表示匹配所有<code>0</code>到<code>9</code>的数字).使用两个星号<code>(**)</code>表示匹配任意中间目录,比如 <code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>或<code>a/b/c/z</code>等.</li>
<li><code>GitHub</code>有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件列表, 你可以在<a href="https://github.com/github/gitignore">gitignore</a>找到它.</li>
<li>在最简单的情况下,一个仓库可能只根目录下有一个 .gitignore 文件,它递归地应用到整个仓库中。 然而,子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore文件中的规则只作用于它所在的目录中。</li>
<li>详情见<code>man gitignore</code></li>
</ul>
<pre><code>$ cat .gitignore
*.[oa]
*~

.gitignore
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a,即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件,而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt,但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf

python .gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/
</code></pre>

<h4 id="_20">查看已暂存和未暂存的修改</h4>
<ul>
<li>如果要查看具体修改了什么地方,使用<code>git diff</code>命令.</li>
<li>当前作的那些更新尚未暂存?</li>
<li>有那些更新已经暂存并准备下次提交?</li>
<li><code>git diff</code>能通过文件补丁的格式更加具体地显示哪些行发生了改变.</li>
</ul>
<pre><code>$ git diff
diff --git a/docs/git.md b/docs/git.md
index f24a5db..b70229f 100644
--- a/docs/git.md
+++ b/docs/git.md
@@ -246,7 +246,7 @@
         Deleted branch dev (was 1780993).
 ```

-## GITPRO
+## GitPro
 注  
:...skipping...
diff --git a/docs/git.md b/docs/git.md
index f24a5db..b70229f 100644
--- a/docs/git.md
+++ b/docs/git.md
@@ -246,7 +246,7 @@
         Deleted branch dev (was 1780993).
 ```

-## GITPRO
+## GitPro
 注  
 - `-&gt;` 在单行中表示上一个命令的结果或输出.

@@ -312,18 +312,215 @@ ls -a

 #### 暂存已经修改的文件
 - 当修改某个已被跟踪的文件后,运行`git status`命令;
-- 文件出现在`Change not staged for commit`下面,说明
+- 文件出现在`Change not staged for commit`下面,说明以追踪文件的内容发生了变化,...
</code></pre>

<ul>
<li><code>git diff</code>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异.即修改后还没有暂存起来的变化内容.</li>
<li>若要查看已暂存的将要添加到下次提交的内容,可以使用<code>git diff --staged</code>命令,这条命令将比对已暂存文件与最后一次提交的文件差异.</li>
<li><code>git diff</code>本身只显示尚未暂存的改动,而不是自上次提交以来所作的改动.</li>
<li><code>git diff --cached</code> 与 <code>git diff --staged</code>是同义词</li>
<li>git diff插件版本,可以使用<code>git difftool</code>命令来调用<code>emerge</code>或<code>vimdiff</code>等软件(包括商业软件)输出diff的分析结果.使用 <code>git difftool --tool-help</code>命令来看你的系统支持哪些Git Diff插件。</li>
</ul>
<pre><code>$ git difftool --tool-help
'git difftool --tool=&lt;tool&gt;' may be set to one of the following:
                emerge
                vimdiff
                vimdiff2
                vimdiff3

The following tools are valid, but not currently available:
                araxis
                ...
</code></pre>

<h4 id="_21">提交更新</h4>
<ul>
<li><code>git commit</code></li>
<li>提交时记录的是放在暂存区域的快照.任何还未暂存文件的仍然保持已修改状态,可以在下次提交时纳入版本管理.每一次运行提交操作,都是对你项目作一次快照,以后可以回到这个状态,或者进行比较.</li>
</ul>
<pre><code>$ git commit -m 'V0.01'
[master 73c4be9] V0.01
 2 files changed, 582 insertions(+), 293 deletions(-)
</code></pre>

<h4 id="_22">跳过使用暂存区域</h4>
<ul>
<li>Git提供了一个跳过使用暂存区域的方式,只要在提交的时候,给<code>git commit</code>加上<code>-a</code>选项,Git就会自动把所有已经跟踪过的文件暂存起来一并提交.</li>
</ul>
<pre><code>$ git commit -a -m 'V0.01_test'
[master db7dd7e] V0.01_test
 1 file changed, 9 insertions(+)
</code></pre>

<h4 id="_23">移除文件</h4>
<ul>
<li>要从Git中移除某个文件,就必须要从已跟踪文件清单中移除(确切地说,是从暂存区域移除),然后提交。可以用<code>git rm</code>命令完成此项工作,并连带从工作目录中删除指定的文件,这样以后就不会出现在未跟踪文件清单中了.</li>
</ul>
<pre><code>$ rm PROJECTS.md
$ git rm PROJECTS.md
</code></pre>

<ul>
<li>下一次提交时,该文件就不再纳入版本管理了.如果要删除之前修改过或已经放到暂存区的文件,则必须使用强制删除选项 -f(译注:即 force的首字母).这是一种安全特性,用于防止误删尚未添加到快照的数据,这样的数据不能被Git恢复.</li>
<li>另外一种情况是想把文件从Git仓库中删除(亦即从暂存区域移除),但仍然希望保留在当前工作目录中。换句话说,想让文件保留在磁盘,但是并不想让Git继续跟踪。为达到这一目的,使用 --cached 选项: <code>git rm --cached README</code></li>
<li><code>git rm</code>命令后面可以列出文件或者目录的名字,也可以使用<code>glob</code>模式,例如:<code>1$ git rm log/\*.log</code>,此命令删除 log/ 目录下扩展名为 .log 的所有文件.</li>
</ul>
<h4 id="_24">移动文件</h4>
<ul>
<li>Git并不显式跟踪文件移动操作, 如果在Git中重命名了某个文件,仓库中存储的元数据并不会体现出这是一次改名操作.</li>
<li><code>$ git mv file_from file_to</code>,在运行<code>git mv</code>时就相当于运行了下面三条命令.</li>
</ul>
<pre><code>$ mv README.md README
$ git rm README.md
$ git add README
</code></pre>

<ul>
<li>如此分开操作,Git也会意识到这是一次重命名,所以不管何种方式结果都一样.两者唯一的区别是,<code>mv</code>是一条命令而非三条命令,直接用 <code>git mv</code>方便得多。不过有时候用其他工具批处理重命名的话,要记得在提交前删除旧的文件名,再添加新的文件名。</li>
</ul>
<h4 id="_25">查看提交历史</h4>
<ul>
<li>查看提交历史.完成这个任务最简单而又有效的工具是<code>git log</code>命令.</li>
<li><code>git log</code>会按时间先后顺序列出所有的提交,最近的更新排在最上面.</li>
<li>选项是<code>-p</code>或<code>--patch</code>,它会显示每次提交所引入的差异(按 补丁 的格式输出),该选项除了显示基本信息之外,还附带了每次提交的变化.</li>
<li>每次提交的简略统计信息,可以使用<code>-stat</code>选项,<code>--stat</code>选项在每次提交的下面列出所有被修改过的文件有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了.</li>
<li><code>--pretty</code>这个选项可以使用不同于默认格式的方式展示提交历史.有<code>oneline</code>,<code>short</code>,<code>full</code>,<code>fuller</code>,<code>format</code>,例如:<code>git log --pretty=format:"%h - %an, %ar : %s"</code></li>
</ul>
<pre><code>    选项    说明
    %H      提交的完整哈希值
    %h      提交的简写哈希值
    %T      树的完整哈希值
    %t      树的简写哈希值
    %P      父提交的完整哈希值
    %p      父提交的简写哈希值
    %an     作者名字
    %ae     作者的电子邮件地址
    %ad     作者修订日期(可以用 --date=选项 来定制格式)
    %ar     作者修订日期,按多久以前的方式显示
    %cn     提交者的名字
    %ce     提交者的电子邮件地址
    %cd     提交日期
    %cr     提交日期(距今多长时间)
    %s      提交说明
</code></pre>

<ul>
<li><code>--graph</code> 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史: 例如:<code>git log --pretty=format:"%h - %an, %ar : %s" --graph</code></li>
<li><code>git log</code>的常用选项</li>
</ul>
<pre><code>-p              按补丁格式显示每个提交引入的差异。
--stat          显示每次提交的文件修改统计信息。
--shortstat     只显示 --stat 中最后的行数修改添加移除统计。
--name-only     仅在提交信息后显示已修改的文件清单。
--name-status   显示新增、修改、删除的文件清单。
--abbrev-commit 仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。
--relative-date 使用较短的相对时间而不是完整格式显示日期(比如“2 weeks ago”)。
--graph         在日志旁以 ASCII 图形显示分支与合并历史。
--pretty        使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format(用来定义自己的格式)。
--oneline --pretty=oneline --abbrev-commit 合用的简写。
</code></pre>

<h4 id="_26">限制输出长度</h4>
<ul>
<li><code>git log --since=2.weeks</code> 命令会列出最近两周的所有提交</li>
<li><code>限制 git log 输出的选项</code></li>
</ul>
<pre><code>    选项                说明
    -&lt;n&gt;                仅显示最近的 n 条提交。
    --since, --after    仅显示指定时间之后的提交。
    --until, --before   仅显示指定时间之前的提交。
    --author            仅显示作者匹配指定字符串的提交。
    --committer         仅显示提交者匹配指定字符串的提交。
    --grep              仅显示提交说明中包含指定字符串的提交。
    -S                  仅显示添加或删除内容匹配指定字符串的提交。
</code></pre>

<pre><code># Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间, 除了合并提交之外的哪一个提交修改了测试文件,
git log --pretty=&quot;%h - %s&quot; --author='Junio C Hamano' --since=&quot;2008-10-01&quot; \
--before=&quot;2008-11-01&quot; --no-merges -- t/
</code></pre>

<h4 id="_27">撤销操作</h4>
<ul>
<li>提交完了才发现漏掉了几个文件没有添加,或者提交信息写错了.运行<code>$ git commit --amend</code>来重新提交.</li>
<li>这个命令会将暂存区中的文件提交.如果自上次提交以来你还未做任何修改,快照会保持不变,所修改的只是提交信息.</li>
</ul>
<h4 id="_28">取消暂存的文件</h4>
<ul>
<li>使用<code>git reset HEAD &lt;file&gt;...</code>来取消暂存</li>
<li><code>git reset</code>确实是个危险的命令,如果加上了<code>--hard</code>选项则更是如此.在上述场景中,工作目录中的文件尚未修改,因此相对安全一些.</li>
</ul>
<h4 id="_29">撤消对文件的修改</h4>
<ul>
<li>请务必记得<code>git restore -- &lt;file&gt;</code>是一个危险的命令.你对那个文件在本地的任何修改都会消失——Git会用最近提交的版本覆盖掉它.</li>
<li>仍然想保留对那个文件做出的修改,但是现在仍然需要撤消,将会在<code>Git分支</code>介绍保存进度与分支,这通常是更好的做法.</li>
<li>在Git中任何已提交的东西几乎总是可以恢复的.甚至那些被删除的分支中的提交或使用<code>--amend</code>选项覆盖的提交也可以恢复.</li>
</ul>
<h4 id="_30">远程仓库的使用</h4>
<ul>
<li>想查已经配置的远程仓库服务器,可以运行<code>git remote &lt;url&gt;</code>命令</li>
</ul>
<pre><code>$ git remote
origin

$ git remote -v
origin  https://github.com/happyfish100/fastdfs.git (fetch)
origin  https://github.com/happyfish100/fastdfs.git (push)
</code></pre>

<ul>
<li>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程 Git 仓库,同时指定一个方便使用的简写</li>
</ul>
<pre><code>$ git remote add pb https://github.com/paulboone/ticgit
</code></pre>

<h4 id="_31">从远程仓库中抓取与拉取</h4>
<ul>
<li>远程仓库中获得数据<code>git fetch &lt;remote&gt;</code> 命令会访问远程仓库,从中拉取所有你还没有的数据。 执行完成后,你将会拥有那个远程仓库中所有分支的引用,可以随时合并或查看.</li>
<li><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li>
<li><code>git pull</code>则是将远程主机的最新内容拉下来后直接合并，即<code>git pull = git fetch + git merge</code>可能会产生冲突，需要手动解决.</li>
<li>如果你使用<code>clone</code>命令克隆了一个仓库,命令会将其添加为远程仓库并默认以<code>origin</code>为简写.<code>git fetch origin</code>会抓取克隆后新推送的所有工作.必须注意<code>git fetch</code>命令只会将数据下载到你的本地仓库——它并不自动合并或修改你当前的工作.当准备好时你必须手动将其合并入你的工作</li>
<li>如果当前分支设置了跟踪远程分支,那么可以用<code>git pull</code>命令来自动抓取后合并该远程分支到当前分支.这或许是个更加简单舒服的工作流程。默认情况下<code>git clone</code>命令会自动设置本地<code>master</code>分支跟踪克隆的远程仓库的<code>master</code>分支.运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支.</li>
</ul>
<h4 id="_32">推送到远程仓库</h4>
<ul>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code>想要将<code>master</code>分支推送到<code>origin</code>服务器时:<code>git push origin master</code></li>
<li>当有克隆服务器的写入权限,并且之前没有人推送过时,这条命令才能生效.当和其他人在同一时间克隆,他们先推送到上游然后你再推送到上游,你的推送就会被拒绝.你必须先抓取他们的工作并将其合并进你的工作后才能推送.</li>
</ul>
<h4 id="_33">查看某个远程仓库</h4>
<ul>
<li><code>git remote show &lt;remote&gt;</code> 查看某一个远程仓库的更多信息</li>
</ul>
<pre><code>* 远程 https://github.com/lvyvan/Possible_Web_Server_Frame
  获取地址：https://github.com/lvyvan/Possible_Web_Server_Frame
  推送地址：https://github.com/lvyvan/Possible_Web_Server_Frame
  HEAD 分支：master
  为 'git push' 配置的本地引用：
    master 推送至 master (本地已过时)
</code></pre>

<h4 id="_34">远程仓库的重命名与移除</h4>
<ul>
<li>运行<code>git remote rename &lt;on&gt; &lt;nn&gt;</code> 来修改一个远程仓库的简写名,也会修改你所有远程跟踪的分支名字.</li>
<li>使用<code>git remote remov</code> 或 <code>git remote rm</code>移除一个远程仓库,</li>
</ul>
<pre><code>git remote remove https://github.com/lvyvan/Possible_Web_Server_Frame
</code></pre>

<h4 id="_35">列出标签</h4>
<ul>
<li>Git 中列出已有的标签<code>git tag</code>,可选的<code>-l</code>选项<code>--list</code>按照通配符列出标签.</li>
</ul>
<h4 id="_36">创建标签</h4>
<ul>
<li>Git支持两种标签:<code>轻量标签(lightweight)</code>与<code>附注标签(annotated)</code>.</li>
<li>量标签很像一个不会改变的分支——它只是某个特定提交的引用。</li>
<li>附注标签是存储在Git数据库中的一个完整对象,可以被校验,包含打标签者的名字,电子邮件,地址,日期时间,此外还有一个标签信息,并且可以使用<code>GNU Privacy Guard (GPG)</code>签名并验证,通常会建议创建附注标签.</li>
</ul>
<h4 id="_37">附注标签</h4>
<ul>
<li>在Git中创建附注标签十分简单,最简单的方式是当你在运行<code>git tag -a &lt;tag&gt; -m '&lt;message&gt;'</code>选项指定一条存储在标签中的信息.</li>
<li>使用<code>git show</code>命令查看标签信息和与之对应的提交信息.</li>
</ul>
<pre><code>$ git show v0.02
tag v0.02
Tagger: lvyvan &lt;yvanlv@outlook.com&gt;
Date:   Sun May 10 19:26:40 2020 +0800

test_0.02

commit df8230eb23b767e3b0fbfae50cc1dee0c7d8356e (HEAD -&gt; master, tag: v0.02)
Author: lvyvan &lt;yvanlv@outlook.com&gt;
Date:   Sun May 10 19:26:07 2020 +0800

    v0.02

diff --git a/docs/git.md b/docs/git.md
index 089da90..f23a993 100644
--- a/docs/git.md
+++ b/docs/git.md
...

</code></pre>

<h4 id="_38">轻量标签</h4>
<ul>
<li>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息.创建轻量标签,不需要使用<code>-a</code>,<code>-s</code>或<code>-m</code>选项.</li>
</ul>
<pre><code>$ git show v1.4-lw
</code></pre>

<h4 id="_39">后期打标签</h4>
<ul>
<li>补上标签 <code>$ git tag -a v1.2 9fceb02</code></li>
</ul>
<h4 id="_40">共享标签</h4>
<ul>
<li>默认<code>git push</code>命令不会传送标签到远程仓库服务器.在创建完标签后显式地推送标签到共享服务器上<code>git push origin &lt;tagname&gt;</code></li>
<li>如一次性推送多个标签,使用带有<code>--tags</code>选项的<code>git push</code>命令.把所有不在远程仓库服务器上的标签全部传送到那里.</li>
<li><code>git push</code>推送两种标签,使用<code>git push &lt;remote&gt; --tags</code>推送标签并不会区分轻量标签和附注标签.</li>
</ul>
<pre><code>$ git push origin --tags
</code></pre>

<h4 id="_41">删除标签</h4>
<ul>
<li>删除本地仓库上的标签,使用命令<code>git tag -d &lt;tagname&gt;</code></li>
<li>上述命令不会从任何远程仓库中移除这个标签,必须用<code>git push &lt;remote&gt;:refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库,含义是,将冒号前面的空值推送到远程标签名.</li>
</ul>
<pre><code>$ git push origin :refs/tags/v1.4-lw To /git@github.com:schacon/simplegit.git
</code></pre>

<ul>
<li>删除远程标签的方式</li>
</ul>
<pre><code>$ git push origin --delete &lt;tagname&gt;
</code></pre>

<h4 id="_42">检出标签</h4>
<ul>
<li>查看某个标签所指向的文件版本,可以使用<code>git checkout</code>命令,会使你的仓库处于“分离头
指针(detacthed HEAD)</li>
</ul>
<h4 id="git_6">Git别名</h4>
<ul>
<li>Git不会在你输入部分命令时自动推断出你想要的命令.如果不想每次都输入完整的 Git 命令,可以通过`git config 文件来轻松地为每一个命令设置一个别名.</li>
<li>当要输入<code>git commit</code>时,只需要输入<code>git ci</code></li>
</ul>
<pre><code>$ config --global alias.co checkout
$ config --global alias.br branch
$ config --global alias.ci commit
$ config --global alias.st status
</code></pre>

<h4 id="git_7">Git分支简介与创建</h4>
<ul>
<li>简介:略</li>
<li>创建新分支:<code>$ git branch testing</code>创建了一个可以移动的新的指针,所在的提交对象上创建一个指针</li>
</ul>
<pre><code>$ git branch testing
$ git log
commit 9c1a767e7bf534fca4ff83c8171b6c2210f04802 (HEAD -&gt; master, testing)
Author: lvyvan &lt;yvanlv@outlook.com&gt;
Date:   Sun May 10 20:33:37 2020 +0800

    0.02_20_5_10
</code></pre>

<h4 id="_43">分支切换</h4>
<ul>
<li>切换到一个已存在的分支,使用<code>git checkout</code>命令</li>
<li>由于Git的分支实质上仅是包含所指对象校验和(长度为40的SHA-1值字符串)的文件,所以它的创建和销毁都异常高效</li>
<li>创建新分支的同时切换过去,用<code>git checkout -b &lt;newbranchname&gt;</code>一条命令搞定</li>
</ul>
<pre><code>$ git checkout testing
M       docs/git.md
切换到分支 'testing'

$ git commit -a -m 'made a change'
[testing 5981040] made a change
 1 file changed, 43 insertions(+), 1 deletion(-)

$ git log
commit 598104011a94d09d304bef23ebc5d8264a1529b1 (HEAD -&gt; testing)
Author: lvyvan &lt;yvanlv@outlook.com&gt;
Date:   Mon May 11 17:33:48 2020 +0800

    made a change

commit 9c1a767e7bf534fca4ff83c8171b6c2210f04802 (master)
Author: lvyvan &lt;yvanlv@outlook.com&gt;
Date:   Sun May 10 20:33:37 2020 +0800

    0.02_20_5_10

$ git checkout master
切换到分支 'master'

$ git log
commit 9c1a767e7bf534fca4ff83c8171b6c2210f04802 (HEAD -&gt; master)
Author: lvyvan &lt;yvanlv@outlook.com&gt;
Date:   Sun May 10 20:33:37 2020 +0800

    0.02_20_5_10

$ git commit -a -m '0.02_0511_a'
[master c323e92] 0.02_0511_a
 1 file changed, 79 insertions(+), 1 deletion(-)
$ git log --oneline --decorate --graph --all
* c323e92 (HEAD -&gt; master) 0.02_0511_a
| * a185174 (testing) made a change2
| * 5981040 made a change
|/  
* 9c1a767 0.02_20_5_10
* df8230e (tag: v0.02) v0.02
* db7dd7e V0.01_test
* 73c4be9 V0.01
* 4b58baa initial project version
</code></pre>

<h4 id="_44">分支的新建与合并</h4>
<ul>
<li>让我们来看一个简单的分支新建与分支合并的例子,实际工作中你可能会用到类似的工作流。 你将经历如下步骤:<blockquote>
<ol>
<li>开发某个网站.</li>
<li>为实现某个新的用户需求,创建一个分支.</li>
<li>在这个分支上开展工作.</li>
</ol>
</blockquote>
</li>
<li>正在此时,你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理:<blockquote>
<ol>
<li>切换到你的线上分支(production branch).</li>
<li>为这个紧急任务新建一个分支,并在其中修复它.</li>
<li>在测试通过之后,切换回线上分支,然后合并这个修补分支,最后将改动推送到线上分支.</li>
<li>切换回你最初工作的分支上,继续工作.</li>
</ol>
</blockquote>
</li>
</ul>
<pre><code>$ git checkout -b hotfix
切换到一个新分支 'hotfix'

$ git commit -a -m 'added a new footer [issue 53]'
[hotfix db43f4a] added a new footer [issue 53]
 1 file changed, 23 insertions(+), 5 deletions(-)

$ git checkout master
切换到分支 'master'
</code></pre>

<ul>
<li>将<code>hotfix</code>分支合并回你的<code>master</code>分支来部署到线上</li>
<li>在合并的时候,应该注意到了<code>快进(fast-forward)</code>这个词.想要合并的分支<code>hotfix</code>所指向的提交的直接后继, Git会直接将指针向前移动,即试图合并两个分支时,若顺着一个分支走下去能够到达另一个分支,那么在合并时,只会简单的将指针向前推进(指针右移),因为这种情况下的合并操作没有需要解决的分歧——这就叫做<code>快进(fast-forward)</code></li>
</ul>
<pre><code>$ git merge hotfix
更新 c323e92..db43f4a
Fast-forward
 docs/git.md | 28 +++++++++++++++++++++++-----
 1 file changed, 23 insertions(+), 5 deletions(-)
</code></pre>

<ul>
<li>这个紧急问题的解决方案发布之后,回到被打断之前时的工作中,应该先删除<code>hotfix</code>分支,因为你已经不再需要它了——<code>master分支</code>已经指向了同一个位置.你可以使用带<code>-d</code>选项的<code>git branch</code>命令来删除分支:<code>$ git branch -d hotfix</code></li>
</ul>
<pre><code>$ git branch -d hotfix
已删除分支 hotfix（曾为 db43f4a）。

$ git log --oneline --decorate --graph --all
* db43f4a (HEAD -&gt; master) added a new footer [issue 53]
* c323e92 0.02_0511_a
| * a185174 (testing) made a change2
| * 5981040 made a change
|/  
* 9c1a767 0.02_20_5_10
* df8230e (tag: v0.02) v0.02
* db7dd7e V0.01_test
* 73c4be9 V0.01
* 4b58baa initial project version
</code></pre>

<ul>
<li>可以切换回正在工作的分支继续你的工作,也就是针对<code>testing</code>问题的那个分支(testing 分支)</li>
</ul>
<pre><code>$ git checkout testing
切换到分支 'testing'

# 因为是笔记环境直接当作学习环境,在这提交后的这一时刻,其维护分支与开发分支的内容是一样的.
# 为了保证笔记不丢失.所以覆盖了master(维护分支内容直接覆盖了测试内容)
$ git commit -a -m '开发分支'
[testing 4a13b73] 开发分支
 1 file changed, 78 insertions(+), 1 deletion(-)

 $ git log --oneline --decorate --graph --all
* 4a13b73 (HEAD -&gt; testing) 开发分支
* a185174 made a change2
* 5981040 made a change
| * 0f94c95 (master) 维护分支
| * db43f4a added a new footer [issue 53]
| * c323e92 0.02_0511_a
|/  
* 9c1a767 0.02_20_5_10
* df8230e (tag: v0.02) v0.02
* db7dd7e V0.01_test
* 73c4be9 V0.01
* 4b58baa initial project version
</code></pre>

<h4 id="_45">分支的合并</h4>
<ul>
<li>在<code>hotfix</code>分支上所做的工作并没有包含到<code>testing</code>分支中.若需要拉取<code>hotfix</code>所做的修改,可以使用<code>git merge master</code>命令将<code>master</code>分支合并入<code>testing</code>分支,也可以等到<code>testing</code>分支完成其使命,再将其合并回<code>master</code>分支.</li>
<li>且打算将工作合并入<code>master</code>分支,需要合并<code>testing</code>支到<code>master</code>分支,这和之前合并<code>hotfix</code>分支所做的工作差不多,你只需要检出到你想合并入的分支,然后运行<code>git merge</code>命令</li>
</ul>
<pre><code>*   bcfd586 (HEAD -&gt; master) 维护分支2
|\  
| * 331fadc (testing) 开发分支2
| * 4a13b73 开发分支
| * a185174 made a change2
| * 5981040 made a change
* | 0f94c95 维护分支
* | db43f4a added a new footer [issue 53]
* | c323e92 0.02_0511_a
|/  
* 9c1a767 0.02_20_5_10
* df8230e (tag: v0.02) v0.02
* db7dd7e V0.01_test
* 73c4be9 V0.01
* 4b58baa initial project version
</code></pre>

<ul>
<li>已经合并分支,不再需要<code>testing</code>分支了,可以在任务追踪系统中关闭此项任务,并删除这个分支.</li>
</ul>
<pre><code>$ git branch -d testing
已删除分支 testing（曾为 331fadc）。

$ git log --oneline --decorate --graph --all
*   bcfd586 (HEAD -&gt; master) 维护分支2
|\  
| * 331fadc 开发分支2
| * 4a13b73 开发分支
| * a185174 made a change2
| * 5981040 made a change
* | 0f94c95 维护分支
* | db43f4a added a new footer [issue 53]
* | c323e92 0.02_0511_a
|/  
* 9c1a767 0.02_20_5_10
* df8230e (tag: v0.02) v0.02
* db7dd7e V0.01_test
* 73c4be9 V0.01
* 4b58baa initial project version
</code></pre>

<h4 id="_46">遇到冲突时的分支合并</h4>
<ul>
<li>如果你在两个不同的分支中,对同一个文件的同一个部分进行了不同的修改,<code>Git</code>就没法干净的合并它们.如果你对<code>testing</code>问题的修改和有关<code>hotfix</code>分支的修改都涉及到同一个文件的同一处,在合并它们的时候就会产生合并冲突.</li>
<li>此时<code>Git</code>做了合并,没有自动地创建一个新的合并提交.Git会暂停下来,等待你去解决合并产生的冲突.可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并(unmerged)状态的文件.</li>
<li>任何因包含合并冲突而有待解决的文件,都会以未合并状态标识出来.Git会在有冲突的文件中加入标准的冲突解决标记,可以打开这些包含冲突的文件然后手动解决冲突.出现冲突的文件会包含一些特殊区段.</li>
<li>这表示<code>HEAD</code>所指示的版本(也就是<code>master分支</code>所在的位置,因为你在运行<code>merge</code>命令的时候已经检出到了这个分支)在这个区段的上半部分(=======的上半部分),而<code>testing分支</code>所指示的版本在<code>=======</code>的下半部分。 为了解决冲突,你必须选择使用由`=======分割的两部分中的一个,或者自行合并这些内容.</li>
<li>上述的冲突解决方案仅保留了其中一个分支的修改,并且<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>,<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行被完全删除了.在解决了所有文件里的冲突之后,对每个文件使用<code>git add</code>命令来将其标记为冲突已解决.一旦暂存这些原本有冲突的文件,Git 就会将它们标记为冲突已解决.</li>
<li>可以再次运行 git status 来确认所有的合并冲突都已被解决.</li>
<li>如果对结果感到满意,并且确定之前有冲突的的文件都已经暂存了,这时可以输入<code>git commit</code>来完成合并提交</li>
</ul>
<h4 id="_47">分支管理</h4>
<ul>
<li><code>git branch</code>命令不只是可以创建与删除分支.如果不加任何参数运行它,会得到当前所有分支的一个列表</li>
</ul>
<pre><code>$ git branch
* master
</code></pre>

<ul>
<li>注意<code>master</code>分支前的<code>*</code>字符:它代表现在检出的那一个分支(也就是说,当前 HEAD 指针所指向的分支)。这意味着如果在这时候提交<code>master</code>分支将会随着新的工作向前移动.</li>
<li>看每一个分支的最后一次提交,可以运行<code>git branch -v</code>命令</li>
</ul>
<pre><code>$ git branch -v
* master bcfd586 维护分支2
</code></pre>

<ul>
<li><code>--merged</code>与<code>--no-merged</code>这两个选项可以过滤列表中已经合并或尚未合并到当前分支的分支.</li>
<li>提供一个附加的参数来查看其它分支的合并状态而不必检出它们,使用<code>git branch --no-merged master</code></li>
</ul>
<pre><code>$ git branch --merged
* master
</code></pre>

<h4 id="_48">长期分支</h4>
<ul>
<li>因为Git使用简单的三方合并,所以就算在一段较长的时间内,反复把一个分支合并入另一个分支,也不是什么难事.</li>
<li>只在 master 分支上保留完全稳定的代码.还有一些名为<code>develop</code>或者<code>next</code>的平行分支,被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定,但是一旦达到稳定状态,它们就可以被合并入<code>master</code>分支了.在确保这些已完成的主题分支(短期分支,比如之前的<code>testing</code>分支)能够通过所有测试,并且不会引入更多<code>bug</code>之后,就可以合并入主干分支中,等待下一次的发布.
-你可以用这种方法维护不同层次的稳定性.一些大型项目还有一个<code>proposed(建议)</code>或<code>pu: proposed updates(建议更新)</code>分支,它可能因包含一些不成熟的内容而不能进入<code>next</code>或者<code>master</code>分支.这么做的目的是使你的分支具有不同级别的稳定性;当它们具有一定程度的稳定性后,再把它们合并入具有更高级别稳定性的分支中.</li>
</ul>
<h4 id="_49">主题分支</h4>
<ul>
<li>主题分支对任何规模的项目都适用.主题分支是一种短期分支,它被用来实现单一特性或其相关工作.在Git中一天之内多次创建、使用、合并、删除分支都很常见.
-这项技术能使你快速并且完整地进行上下文切换(context-switch)——因为你的工作被分散到不同的流水线中,在不同的流水线中每个分支都仅与其目标特性相关,因此,在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动.你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月,等它们成熟之后再合并,而不用在乎它们建立的顺序或工作进度.</li>
</ul>
<h4 id="_50">远程分支</h4>
<ul>
<li>远程引用是对远程仓库的引用(指针),包括分支、标签等等</li>
<li>你可以通过<code>git ls-remote &lt;remote&gt;</code>来显式地获得远程引用的完整列表,或者通过<code>git remote show &lt;remote&gt;</code>获得远程分支的更多信息.然而,一个更常见的做法是利用远程跟踪分支.</li>
<li>远程跟踪分支是远程分支状态的引用.它们是你无法移动的本地引用.一旦你进行了网络通信,Git就会为你移动它们以精确反映远程仓库的状态.请将它们看做书签,这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置.</li>
<li>它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>的形式命名.</li>
<li>想要看你最后一次与远程仓库<code>origin</code>通信时<code>master</code>分支的状态,你可以查看<code>origin/master</code>分支.你与同事合作解决一个问题并且他们推送了一个<code>iss53</code>分支,你可能有自己的本地<code>iss53</code>分支, 然而在服务器上的分支会以<code>origin/iss53</code>来表示.</li>
<li>假设网络里有一个在<code>git.ourcompany.com</code>的Git服务器.如果你从这里克隆,<code>git clone</code>命令会为你自动将其命名为origin,拉取它的所有数据, 创建一个指向它的<code>master</code>分支的指针,并且在本地将其命名为<code>origin/master</code>.Git也会给你一个与<code>origin</code>的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支.</li>
<li><code>origin</code>并无特殊含义,远程仓库名字<code>origin</code>与分支名字<code>master</code>一样,在<code>Git</code>中并没有任何特别的含义一样.同时<code>master</code>是当你运行<code>git init</code>时默认的起始分支名字,原因仅仅是它的广泛使用.<code>origin</code>是当你运行<code>git clone</code>时默认的远程仓库名字.如果你运行<code>git clone -o booyah</code>,那么你默认的远程分支名字将会是<code>booyah/master</code>.</li>
<li>如果你在本地的<code>master</code>分支做了一些工作,在同一段时间内有其他人推送提交到<code>git.ourcompany.com</code>并且更新了它的<code>master</code>分支,这就是说你们的提交历史已走向不同的方向.即便这样,只要你保持不与<code>origin</code>服务器连接(并拉取数据),你的<code>origin/master</code>指针就不会移动.</li>
<li>如果要与给定的远程仓库同步数据,运行<code>git fetch &lt;remote&gt;</code>命令(在本例中为<code>git fetch origin</code>).这个命令查找<code>origin</code>是哪一个服务器(在本例中,它是<code>git.ourcompany.com</code>),从中抓取本地没有的数据,并且更新本地数据库,移动<code>origin/master</code>指针到更新之后的位置.</li>
<li>为了演示有多个远程仓库与远程分支的情况,假定你有另一个内部Git服务器,仅服务于你的某个敏捷开发团队.这个服务器位于<code>git.team1.ourcompany.com</code>.你可以运行<code>git remote add</code>命令添加一个新的远程仓库引用到当前的项目,这个命令我们会在<code>Git基础</code>中详细说明.将这个远程仓库命名为<code>teamone</code>,将其作为完整<code>URL</code>的缩写.</li>
<li>可以运行<code>git fetch teamone</code>来抓取远程仓库<code>teamone</code>有而本地没有的数据.因为那台服务器上现有的数据是<code>origin</code>服务器上的一个子集,所以<code>Git</code>并不会抓取数据而是会设置远程跟踪分支<code>teamone/master</code>指向<code>teamone</code>的<code>master</code>分支.</li>
</ul>
<h4 id="_51">推送</h4>
<ul>
<li>当你想要公开分享一个分支时,需要将其推送到有写入权限的远程仓库上.本地的分支并不会自动与远程仓库同步——必须显式地推送想要分享的分支.</li>
<li>如果希望和别人一起在名为<code>serverfix</code>的分支上工作,可以像推送第一个分支那样推送它.运行<code>git push &lt;remote&gt; &lt;branch&gt;</code>.</li>
</ul>
<pre><code>$ git push origin serverfix
</code></pre>

<ul>
<li>Git自动将<code>serverfix</code>分支名字展开为<code>refs/heads/serverfix:refs/heads/serverfix</code>,推送本地的<code>serverfix分支</code>来更新远程仓库上的<code>serverfix 分支</code>.</li>
<li>可以运行<code>git push origin serverfix:serverfix</code>它会做同样的事——也就是说推送本地的<code>serverfix分支</code>,将其作为远程仓库的<code>serverfix 分支</code>可以通过这种格式来推送本地分支到一个命名不相同的远程分支.</li>
<li>如果并不想让远程仓库上的分支叫做<code>serverfix</code>,可以运行<code>git push origin serverfix:awesomebranch</code>来将本地的<code>serverfix</code>分支推送到远程仓库上的<code>awesomebranch</code>分支.</li>
<li>当抓取到新的远程跟踪分支时,本地不会自动生成一份可编辑的副本(拷贝). 不会有一个新的<code>serverfix分支</code>.只有一个不可以修改的 <code>origin/serverfix</code>指针.可以运行<code>git merge origin/serverfix</code>将这些工作合并到当前所在的分支.如果想要在自己的
<code>serverfix分支</code>上工作,可以将其建立在远程跟踪分支之上.</li>
<li>用于工作的本地分支,并且起点位于origin/serverfix:<code>git checkout -b serverfix origin/serverfix</code></li>
</ul>
<h4 id="_52">跟踪分支</h4>
<ul>
<li>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”(它跟踪的分支叫做“上游分支”).跟踪分支是与远程分支有直接关系的本地分支.</li>
<li>如果在一个跟踪分支上输入<code>git pull</code>,Git能自动地识别去哪个服务器上抓取、合并到哪个分支.</li>
<li>当克隆一个仓库时,它通常会自动地创建一个跟踪<code>origin/master</code>的<code>master分支</code>.可以设置其他的跟踪分支,或是一个在其他远程仓库上的跟踪分支,又或者不跟踪<code>master分支</code>.</li>
<li>运行<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>.这是一个十分常用的操作所以Git提供了<code>--track</code>快捷方式</li>
</ul>
<pre><code>$ git checkout --track origin/serverfix
</code></pre>

<ul>
<li>尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支,创建一个跟踪分支</li>
</ul>
<pre><code>$ git checkout serverfix
</code></pre>

<ul>
<li>将本地分支与远程分支设置为不同的名字,可以轻松地使用上一个命令增加一个不同名字的本地分支,本地分支sf会自动从<code>origin/serverfix</code>拉取</li>
</ul>
<pre><code>$ git checkout -b sf origin/serverfix
</code></pre>

<ul>
<li>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支,或者想要修改正在跟踪的上游分支,你可以在任意时间使用<code>-u</code>或 <code>--set-upstream-to</code>选项运行<code>git branch</code>来显式地设置</li>
</ul>
<pre><code>$ git branch -u origin/serverfix
</code></pre>

<ul>
<li>上游快捷方式,当设置好跟踪分支后,可以通过简写<code>@{upstream}</code>或<code>@{u}</code>来引用它的上游分支.所以在<code>master</code>分支时并且它正在跟踪<code>origin/master</code>时,可以使用<code>git merge @{u}</code>来取代<code>git merge origin/master</code></li>
</ul>
<h4 id="p92">P92</h4>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../cshirp/" class="btn btn-neutral float-right" title="C#">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../mongodb/" class="btn btn-neutral" title="MongoDB"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../mongodb/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../cshirp/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
